<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Front end analysis - Collingo
    </title>
    <link rel="alternate" href="http://collingo.com//feed.xml" type="application/rss+xml" title="JavaScript and Front-end Web Developer">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body class="article-detail">
    <header class="header">
      <div class="content-wrap">
        <h1>Front end analysis</h1>
        <p class="author">Written by <span class="author">Nick Collings</span>, 05. April 2014
        </p>
      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article">
          <section class="content"><p>I’ve had my frustrations with front end application frameworks/libraries for a while now. None of them are quite perfect. I’d like to get down what I’d like to see and feel should be&nbsp;feasible.</p>
<ol>
<li>Self contained functional view components - pass them data, a template and a little view-model mapping magic and you’re off! On the server these return <span class="caps">HTML</span>, on the client they produce ready-bound DOM.<ol>
<li>Two-way data binding built in as standard on the client&nbsp;side.</li>
<li>View logic defined declaratively in the&nbsp;templates.</li>
<li>A simple way to map the data-model to the&nbsp;view-model.</li>
</ol>
</li>
<li>Sharable logic<ol>
<li>Routing - just needs to invoke a&nbsp;controller.</li>
<li>Controllers - a controller defines a mapping of a layout, to functional components, to data. This mapping exists, in the same form, on both the server and client so it should be&nbsp;sharable.</li>
<li>Models - business logic exists independent of any presentation format so should easily be&nbsp;sharable.</li>
<li>Views - compiled as they are on the front end, not from some nested set of Jade templates but as the output of the controllers compilation of layout, model and view&nbsp;components.</li>
</ol>
</li>
<li>Templates that can be used as blueprints to both compile and parse <span class="caps">HTML</span>/DOM. This is a big one. The ability to compile HTML is the well trodden path of templating languages. The next step, as I see it, would be to define a template once and then use it to both generate ready-bound DOM and also to augment any existing unbound DOM with bindings. The latter is particularly important as it opens up the options of server side view rendering. Perceived load times would be shorter and the requirement of JS rendering would be removed&nbsp;entirely.</li>
</ol>
</section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/">« Full blog</a></div>
        <section class="links"><ul>
<li><a href="http://twitter.com/collingo">Twitter</a></li>
<li><a href="http://github.com/collingo">GitHub</a></li>
<li><a href="http://linkedin.com/in/nickcollings">LinkedIn</a></li>
</ul>

        </section>
        <section class="copy">
          <p>&copy; 2014 Nick Collings &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-23044626-1', 'collingo.com');
      ga('send', 'pageview');
    </script>
  </body>
</html>