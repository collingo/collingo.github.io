<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width">
    <title>Collingo
    </title>
    <link rel="alternate" href="http://collingo.com//feed.xml" type="application/rss+xml" title="JavaScript and Front-end Web Developer">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Anonymous+Pro:400,700,400italic,700italic|Merriweather:400,700,300">
    <link rel="stylesheet" href="/css/main.css">
  </head>
  <body>
    <header class="header">
      <div class="content-wrap">
        <div class="logo">
          <h1><a href="/">Collingo</a></h1>
          <p class="description">JavaScript and Front-end Web Developer</p>
        </div><p>JavaScript developer with a passion for architecting and building client-side web applications. Several years wide ranging experience, from leading large front-end builds to getting elbow deep in test driven code on highly-interactive, data-driven apps.</p>
<p>Constant exploration has given me production experience in a wide range of technologies and I am always keen to try more. Most of all, I still get a kick out of turning ideas into beautifully functional, well architected products using lean, modular code and a text editor.</p>

      </div>
    </header>
    <div id="content">
      <div class="content-wrap">
        <article class="article intro">
          <header>
            <p class="date"><span>05. April 2014</span></p>
            <h2><a href="/articles/client-vs-server-side-rendering/">Client vs server side rendering</a></h2>
          </header>
          <section class="content"><p>One of the biggest problems with the front end web application stack is the lack of code sharing. This is particularly frustrating when it comes to rendering. We are forced to have two different rendering contexts; one for the server, one for the client. At first this seems reasonable - the server needs only produce one mammoth piece of static <span class="caps">HTML</span> whilst the client needs to be more dynamic and modular. While this will always be true, I believe we have overlooked some opportunities for code&nbsp;sharing.</p>
<p>The old web application architecture (Rails and Django etc) saw all the logic and rendering on the server. The client was little more than a web page renderer with full reloads between each view/action. This resulted in a clunky feel to the application which ultimately could not compete with a native&nbsp;experience.</p>
<p>More recent solutions like Backbone (which I have been using for 3 years or so now) sought to take advantage of <span class="caps">AJAX</span> to provide richer interfaces. Apps started to feel faster, slicker, and allowed for more complex visuals and interactions. Definitely a positive move. Unfortunately this richness came with the caveat that all the rendering takes place on the client. This has reuslted in many apps having slow initial render times and sometimes even the dreaded loading bars of the Flash era. Where we have gained we have lost elsewhere. Apart from anything else this clearly wastes the power of the server turning it into a dumb web server and data&nbsp;provider.</p>
<p>While I understand you cannot always expect complete render parity between client and server (the server shouldn’t be handling every single interactions via full page reloads and the client probably shouldn’t be juggling massive data sets either) I feel the black or white options we have available to us are too simple. A balance must be struck. We can do&nbsp;better.</p>
<h4 id="what-can-we-do-">What can we&nbsp;do?</h4>
<p>As I mentioned in an <a href="/articles/front-end-analysis/">earlier post</a> I believe templating is a key area to look at. Templates can do more than just compile down to <span class="caps">HTML</span>. In fact we are seeing solutions like <a href="http://www.ractivejs.org/">Ractive</a> from the tech heads at the Guardian take bolder steps. They take an only slightly enhanced super set of <a href="http://handlebarsjs.com/">Handlebars</a> and give you back a nice two-way bound <span class="caps">DOM</span>, ready to roll. Everyone knows Google’s <a href="http://angularjs.org/">Angular</a> gives us the same in a more declarative form, using the <span class="caps">DOM</span> as the template. Again another great step but both solutions leave the server out in the cold, rendering partial views and leaving the rest to the&nbsp;client.</p>
<p>To improve on this, I’d like to see templates treated like blueprints which could be used in one of the following ways;&nbsp;either</p>
<ul>
<li>taking a model and producing <span class="caps">HTML</span>&nbsp;or</li>
<li>taking a model and producing a ready-bound <span class="caps">DOM</span> fragment&nbsp;or</li>
<li>taking some unbound <span class="caps">DOM</span> and binding it to an existing&nbsp;model</li>
</ul>
<p>The first is the process we are familar with from the Backbone universe - producing <span class="caps">HTML</span> is still a cumbersome approach on the client but still necessary for the server. The second covers client side rendering as with Ractive’s techniques. The final approach would be massively useful when working with pages pre-rendered on the server (using the first approach incidentally). Angular has made a move towards the latter but expects templates in the DOM rather than the final mark&nbsp;up.</p>
<h4 id="that-s-a-tall-order-what-would-this-require-">That’s a tall order. What would this&nbsp;require?</h4>
<p>Templates would need to output <span class="caps">HTML</span>/DOM such that the data model bindings can be inferred using only the original template as a reference. Essentially templates that allow for reverse&nbsp;compilation.</p>
<p>Current languages, such as Handlebars, support features that prevent the original template being inferred from the <span class="caps">HTML</span>, as highlighted by blerik’s <a href="http://stackoverflow.com/a/19271995">this excellent Stack Overflow answer</a>. Using a subset, aligning to blerik’s rules, should give us a workable&nbsp;solution.</p>

          </section>
        </article>
        <article class="article intro">
          <header>
            <p class="date"><span>05. April 2014</span></p>
            <h2><a href="/articles/front-end-analysis/">Front end analysis</a></h2>
          </header>
          <section class="content"><p>I’ve had my frustrations with front end application frameworks/libraries for a while now. None of them are quite perfect. I’d like to get down what I’d like to see and feel should be&nbsp;feasible.</p>
<ol>
<li>Self contained functional view components - pass them data, a template and a little view-model mapping magic and you’re off! On the server these return <span class="caps">HTML</span>, on the client they produce ready-bound DOM.<ol>
<li>Two-way data binding built in as standard on the client&nbsp;side.</li>
<li>View logic defined declaratively in the&nbsp;templates.</li>
<li>A simple way to map the data-model to the&nbsp;view-model.</li>
</ol>
</li>
<li>Sharable logic<ol>
<li>Routing - just needs to invoke a&nbsp;controller.</li>
<li>Controllers - a controller defines a mapping of a layout, to functional components, to data. This mapping exists, in the same form, on both the server and client so it should be&nbsp;sharable.</li>
<li>Models - business logic exists independent of any presentation format so should easily be&nbsp;sharable.</li>
<li>Views - compiled as they are on the front end, not from some nested set of Jade templates but as the output of the controllers compilation of layout, model and view&nbsp;components.</li>
</ol>
</li>
<li>Templates that can be used as blueprints to both compile and parse <span class="caps">HTML</span>/DOM. This is a big one. The ability to compile HTML is the well trodden path of templating languages. The next step, as I see it, would be to define a template once and then use it to both generate ready-bound DOM and also to augment any existing unbound DOM with bindings. The latter is particularly important as it opens up the options of server side view rendering. Perceived load times would be shorter and the requirement of JS rendering would be removed&nbsp;entirely.</li>
</ol>

          </section>
        </article>
      </div>
    </div>
    <footer>
      <div class="content-wrap">
        <div class="nav"><a href="/archive.html">« Archives</a>
        </div>
        <section class="links"><ul>
<li><a href="http://twitter.com/collingo">Twitter</a></li>
<li><a href="http://github.com/collingo">GitHub</a></li>
<li><a href="http://linkedin.com/in/nickcollings">LinkedIn</a></li>
</ul>

        </section>
        <section class="copy">
          <p>&copy; 2014 Nick Collings &mdash; powered by&nbsp;<a href="https://github.com/jnordberg/wintersmith">Wintersmith</a>
          </p>
        </section>
      </div>
    </footer>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      
      ga('create', 'UA-23044626-1', 'collingo.com');
      ga('send', 'pageview');
    </script>
  </body>
</html>